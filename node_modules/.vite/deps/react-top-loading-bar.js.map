{
  "version": 3,
  "sources": ["../../react-top-loading-bar/src/useInterval.ts", "../../react-top-loading-bar/src/utils.ts", "../../react-top-loading-bar/src/index.tsx"],
  "sourcesContent": ["import { useEffect, useRef } from 'react'\n\n/** keep typescript happy */\nconst noop = () => {}\n\nexport function useInterval(\n  callback: () => void,\n  delay: number | null | false,\n  immediate?: boolean\n) {\n  const savedCallback = useRef(noop)\n\n  // Remember the latest callback.\n  useEffect(() => {\n    savedCallback.current = callback\n  })\n\n  // Execute callback if immediate is set.\n  useEffect(() => {\n    if (!immediate) return\n    if (delay === null || delay === false) return\n    savedCallback.current()\n  }, [immediate])\n\n  // Set up the interval.\n  useEffect(() => {\n    if (delay === null || delay === false) return undefined\n    const tick = () => savedCallback.current()\n    const id = setInterval(tick, delay)\n    return () => clearInterval(id)\n  }, [delay])\n}\n\nexport default useInterval\n", "export function randomValue(min: number, max: number): number {\n  return (Math.random() * (max - min + 1) + min)\n}\n\nexport function randomInt(min: number, max: number): number {\n  return Math.floor(randomValue(min, max))\n}\n", "import * as React from 'react'\nimport {\n  CSSProperties,\n  useEffect,\n  useState,\n  forwardRef,\n  useImperativeHandle,\n  useRef,\n} from 'react'\nimport { useInterval } from './useInterval'\nimport { randomInt, randomValue } from './utils'\n\nexport type IProps = {\n  progress?: number\n  color?: string\n  shadow?: boolean\n  background?: string\n  height?: number\n  onLoaderFinished?: () => void\n  className?: string\n  containerClassName?: string\n  loaderSpeed?: number\n  transitionTime?: number\n  waitingTime?: number\n  style?: CSSProperties\n  containerStyle?: CSSProperties\n  shadowStyle?: CSSProperties\n}\n\nexport type LoadingBarRef = {\n  continuousStart: (startingValue?: number, refreshRate?: number) => void\n  staticStart: (startingValue?: number) => void\n  complete: () => void;\n}\n\nconst LoadingBar = forwardRef<LoadingBarRef, IProps>(\n  (\n    {\n      progress,\n      height = 2,\n      className = '',\n      color = 'red',\n      background = 'transparent',\n      onLoaderFinished,\n      transitionTime = 300,\n      loaderSpeed = 500,\n      waitingTime = 1000,\n      shadow = true,\n      containerStyle = {},\n      style = {},\n      shadowStyle: shadowStyleProp = {},\n      containerClassName = ''\n    },\n    ref\n  ) => {\n    const isMounted = useRef(false);\n    const [localProgress, localProgressSet] = useState<number>(0)\n\n    const pressedContinuous = useRef<{\n      active: boolean\n      refreshRate: number\n    }>({ active: false, refreshRate: 1000 })\n\n    const [usingProps, setUsingProps] = useState(false)\n\n    const [pressedStaticStart, setStaticStartPressed] = useState<{\n      active: boolean\n      value: number\n    }>({ active: false, value: 20 })\n\n    const initialLoaderStyle: CSSProperties = {\n      height: '100%',\n      background: color,\n      transition: `all ${loaderSpeed}ms ease`,\n      width: '0%',\n    }\n\n    const loaderContainerStyle: CSSProperties = {\n      position: 'fixed',\n      top: 0,\n      left: 0,\n      height,\n      background,\n      zIndex: 99999999999,\n      width: 100 + '%',\n    }\n\n    const initialShadowStyles: CSSProperties = {\n      boxShadow: `0 0 10px ${color}, 0 0 10px ${color}`,\n      width: '5%',\n      opacity: 1,\n      position: 'absolute',\n      height: '100%',\n      transition: `all ${loaderSpeed}ms ease`,\n      transform: 'rotate(3deg) translate(0px, -4px)',\n      left: '-10rem',\n    }\n\n    const [loaderStyle, loaderStyleSet] = useState<CSSProperties>(\n      initialLoaderStyle\n    )\n    const [shadowStyle, shadowStyleSet] = useState<CSSProperties>(\n      initialShadowStyles\n    )\n\n    useEffect(() => {\n      isMounted.current = true;\n      return () => {\n        isMounted.current = false;\n      }\n    }, []);\n\n    useImperativeHandle(ref, () => ({\n      continuousStart(startingValue?: number, refreshRate: number = 1000) {\n        if (pressedStaticStart.active) return\n        if (usingProps) {\n          console.warn(\n            \"react-top-loading-bar: You can't use both controlling by props and ref methods to control the bar!\"\n          )\n          return\n        }\n\n        const val = startingValue || randomInt(10, 20)\n\n        pressedContinuous.current = ({\n          active: true,\n          refreshRate,\n        })\n\n        localProgressSet(val)\n        checkIfFull(val)\n      },\n      staticStart(startingValue?: number) {\n        if (pressedContinuous.current.active) return\n        if (usingProps) {\n          console.warn(\n            \"react-top-loading-bar: You can't use both controlling by props and ref methods to control the bar!\"\n          )\n          return\n        }\n\n        const val = startingValue || randomInt(30, 50)\n\n        setStaticStartPressed({\n          active: true,\n          value: val,\n        })\n        localProgressSet(val)\n        checkIfFull(val)\n      },\n      complete() {\n        if (usingProps) {\n          console.warn(\n            \"react-top-loading-bar: You can't use both controlling by props and ref methods to control the bar!\"\n          )\n          return\n        }\n        localProgressSet(100)\n        checkIfFull(100)\n      },\n    }))\n\n    useEffect(() => {\n      loaderStyleSet({\n        ...loaderStyle,\n        background: color,\n      })\n\n      shadowStyleSet({\n        ...shadowStyle,\n        boxShadow: `0 0 10px ${color}, 0 0 5px ${color}`,\n      })\n    }, [color])\n\n    useEffect(() => {\n      if (ref) {\n        if (ref && progress !== undefined) {\n          console.warn(\n            'react-top-loading-bar: You can\\'t use both controlling by props and ref methods to control the bar! Please use only props or only ref methods! Ref methods will override props if \"ref\" property is available.'\n          )\n          return\n        }\n        checkIfFull(localProgress)\n        setUsingProps(false)\n      } else {\n        if (progress) checkIfFull(progress)\n\n        setUsingProps(true)\n      }\n    }, [progress])\n\n    const checkIfFull = (_progress: number) => {\n      if (_progress >= 100) {\n        // now it should wait a little\n        loaderStyleSet({\n          ...loaderStyle,\n          width: '100%',\n        })\n        if (shadow) {\n          shadowStyleSet({\n            ...shadowStyle,\n            left: _progress - 10 + '%',\n          })\n        }\n\n        setTimeout(() => {\n          if (!isMounted.current) {\n            return;\n          }\n          // now it can fade out\n          loaderStyleSet({\n            ...loaderStyle,\n            opacity: 0,\n            width: '100%',\n            transition: `all ${transitionTime}ms ease-out`,\n            color: color,\n          })\n\n          setTimeout(() => {\n            if (!isMounted.current) {\n              return;\n            }\n            // here we wait for it to fade\n            if (pressedContinuous.current.active) {\n              // if we have continuous loader just ending, we kill it and reset it\n\n              pressedContinuous.current = {\n                ...pressedContinuous.current,\n                active: false,\n              };\n\n              localProgressSet(0)\n              checkIfFull(0)\n            }\n\n            if (pressedStaticStart.active) {\n              setStaticStartPressed({\n                ...pressedStaticStart,\n                active: false,\n              })\n              localProgressSet(0)\n              checkIfFull(0)\n            }\n\n            if (onLoaderFinished) onLoaderFinished()\n            localProgressSet(0)\n            checkIfFull(0)\n          }, transitionTime)\n        }, waitingTime)\n      } else {\n        loaderStyleSet((_loaderStyle) => {\n          return {\n            ..._loaderStyle,\n            width: _progress + '%',\n            opacity: 1,\n            transition: _progress > 0 ? `all ${loaderSpeed}ms ease` : '',\n          }\n        })\n\n        if (shadow) {\n          shadowStyleSet({\n            ...shadowStyle,\n            left: _progress - 5.5 + '%',\n            transition: _progress > 0 ? `all ${loaderSpeed}ms ease` : '',\n          })\n        }\n      }\n    }\n\n    useInterval(\n      () => {\n        const minValue = Math.min(10, (100 - localProgress) / 5);\n        const maxValue =  Math.min(20, (100 - localProgress) / 3)\n\n        const random = randomValue(minValue, maxValue);\n\n        if (localProgress + random < 95) {\n          localProgressSet(localProgress + random)\n          checkIfFull(localProgress + random)\n        }\n      },\n      pressedContinuous.current.active ? pressedContinuous.current.refreshRate : null\n    )\n\n    return (\n      <div className={containerClassName} style={{...loaderContainerStyle, ...containerStyle}}>\n        <div className={className} style={{...loaderStyle, ...style}}>\n          {shadow ? <div style={{...shadowStyle, ...shadowStyleProp}} /> : null}\n        </div>\n      </div>\n    )\n  }\n)\n\nexport default LoadingBar\n"],
  "mappings": "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",
  "names": ["noop", "randomValue", "min", "max", "Math", "random", "randomInt", "floor", "LoadingBar", "forwardRef", "o", "ref", "progress", "height", "className", "color", "background", "onLoaderFinished", "transitionTime", "loaderSpeed", "waitingTime", "shadow", "containerStyle", "style", "shadowStyle", "shadowStyleProp", "containerClassName", "isMounted", "useRef", "useState", "localProgress", "localProgressSet", "pressedContinuous", "active", "refreshRate", "usingProps", "setUsingProps", "value", "pressedStaticStart", "setStaticStartPressed", "loaderContainerStyle", "position", "top", "left", "zIndex", "width", "initialShadowStyles", "boxShadow", "opacity", "transition", "transform", "loaderStyle", "loaderStyleSet", "shadowStyleSet", "useEffect", "current", "useImperativeHandle", "continuousStart", "startingValue", "console", "warn", "val", "checkIfFull", "staticStart", "complete", "callback", "delay", "savedCallback", "_progress", "setTimeout", "_loaderStyle", "immediate", "id", "setInterval", "clearInterval", "React"]
}
