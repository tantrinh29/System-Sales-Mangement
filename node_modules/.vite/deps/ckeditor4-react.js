import {
  require_react_is
} from "./chunk-AIWIYUBO.js";
import {
  require_react
} from "./chunk-RDZYK52F.js";
import {
  __commonJS,
  __toESM
} from "./chunk-5WWUZCGV.js";

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/prop-types/lib/has.js"(exports, module) {
    module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports, module) {
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has = require_has();
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has;
    function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error(
                  (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                err.name = "Invariant Violation";
                throw err;
              }
              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning(
                (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
              );
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning(
                "Failed " + location + " type: " + error.message + (stack != null ? stack : "")
              );
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module.exports = checkPropTypes;
  }
});

// node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
    "use strict";
    var ReactIs = require_react_is();
    var assign = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module.exports = function(isValidElement, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is(x, y) {
        if (x === y) {
          return x !== 0 || 1 / x === 1 / y;
        } else {
          return x !== x && y !== y;
        }
      }
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3) {
                printWarning(
                  "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
              { expectedType }
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i = 0; i < propValue.length; i++) {
            var error = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning(
                "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
              );
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i = 0; i < expectedValues.length; i++) {
            if (is(propValue, expectedValues[i])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
            var type = getPreciseType(value);
            if (type === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has(propValue, key)) {
              var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (typeof checker !== "function") {
            printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + "."
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
            var checker2 = arrayOfTypeCheckers[i2];
            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          if (!isNode(props[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError(
          (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
        );
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has(shapeTypes, key) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function isNode(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case "array":
          case "object":
            return "an " + type;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type;
          default:
            return type;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports, module) {
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// node_modules/ckeditor4-react/dist/index.esm.js
var React = __toESM(require_react());

// node_modules/ckeditor4-integrations-common/dist/index.esm.js
function loadScript(src, opts, cb) {
  var head = document.head || document.getElementsByTagName("head")[0];
  var script = document.createElement("script");
  if (typeof opts === "function") {
    cb = opts;
    opts = {};
  }
  opts = opts || {};
  cb = cb || function() {
  };
  script.type = opts.type || "text/javascript";
  script.charset = opts.charset || "utf8";
  script.async = "async" in opts ? !!opts.async : true;
  script.src = src;
  if (opts.attrs) {
    setAttributes(script, opts.attrs);
  }
  if (opts.text) {
    script.text = String(opts.text);
  }
  var onend = "onload" in script ? stdOnEnd : ieOnEnd;
  onend(script, cb);
  if (!script.onload) {
    stdOnEnd(script, cb);
  }
  head.appendChild(script);
}
function setAttributes(script, attrs) {
  for (var attr in attrs) {
    script.setAttribute(attr, attrs[attr]);
  }
}
function stdOnEnd(script, cb) {
  script.onload = function() {
    this.onerror = this.onload = null;
    cb(null, script);
  };
  script.onerror = function() {
    this.onerror = this.onload = null;
    cb(new Error("Failed to load " + this.src), script);
  };
}
function ieOnEnd(script, cb) {
  script.onreadystatechange = function() {
    if (this.readyState != "complete" && this.readyState != "loaded") {
      return;
    }
    this.onreadystatechange = null;
    cb(null, script);
  };
}
var promise;
function getEditorNamespace(editorURL, onNamespaceLoaded) {
  if ("CKEDITOR" in window) {
    return Promise.resolve(CKEDITOR);
  }
  if (typeof editorURL !== "string" || editorURL.length < 1) {
    return Promise.reject(new TypeError("CKEditor URL must be a non-empty string."));
  }
  if (!promise) {
    promise = getEditorNamespace.scriptLoader(editorURL).then(function(res) {
      if (onNamespaceLoaded) {
        onNamespaceLoaded(res);
      }
      return res;
    });
  }
  return promise;
}
getEditorNamespace.scriptLoader = function(editorURL) {
  return new Promise(function(scriptResolve, scriptReject) {
    loadScript(editorURL, function(err) {
      promise = void 0;
      if (err) {
        return scriptReject(err);
      } else if (!window.CKEDITOR) {
        return scriptReject(new Error("Script loaded from editorUrl doesn't provide CKEDITOR namespace."));
      }
      scriptResolve(CKEDITOR);
    });
  });
};

// node_modules/ckeditor4-react/dist/index.esm.js
var PropTypes = __toESM(require_prop_types());
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
var events = [
  "activeEnterModeChange",
  "activeFilterChange",
  "afterCommandExec",
  "afterInsertHtml",
  "afterPaste",
  "afterPasteFromWord",
  "afterSetData",
  "afterUndoImage",
  "ariaEditorHelpLabel",
  "ariaWidget",
  "autogrow",
  "beforeCommandExec",
  "beforeDestroy",
  "beforeGetData",
  "beforeModeUnload",
  "beforeSetMode",
  "beforeUndoImage",
  "blur",
  "change",
  "configLoaded",
  "contentDirChanged",
  "contentDom",
  "contentDomInvalidated",
  "contentDomUnload",
  "contentPreview",
  "customConfigLoaded",
  "dataFiltered",
  "dataReady",
  "destroy",
  "dialogHide",
  "dialogShow",
  "dirChanged",
  "doubleclick",
  "dragend",
  "dragstart",
  "drop",
  "elementsPathUpdate",
  "exportPdf",
  "fileUploadRequest",
  "fileUploadResponse",
  "floatingSpaceLayout",
  "focus",
  "getData",
  "getSnapshot",
  "insertElement",
  "insertHtml",
  "insertText",
  "instanceReady",
  "key",
  "langLoaded",
  "loadSnapshot",
  "loaded",
  "lockSnapshot",
  "maximize",
  "menuShow",
  "mode",
  "notificationHide",
  "notificationShow",
  "notificationUpdate",
  "paste",
  "pasteFromWord",
  "pluginsLoaded",
  "readOnly",
  "removeFormatCleanup",
  "required",
  "resize",
  "save",
  "saveSnapshot",
  "selectionChange",
  "setData",
  "stylesRemove",
  "stylesSet",
  "template",
  "toDataFormat",
  "toHtml",
  "uiSpace",
  "unlockSnapshot",
  "updateSnapshot",
  "widgetDefinition"
];
var namespaceEvents = ["beforeLoad", "namespaceLoaded"];
var defaultEvents = __spreadArray(__spreadArray([], events, true), namespaceEvents, true);
var EVENT_PREFIX = "__CKE__";
function prefixEventName(evtName) {
  return "".concat(EVENT_PREFIX).concat(evtName);
}
function stripPrefix(prefixedEventName) {
  return prefixedEventName.substr(EVENT_PREFIX.length);
}
function eventNameToHandlerName(evtName) {
  var cap = evtName.substr(0, 1).toUpperCase() + evtName.substr(1);
  return "on".concat(cap);
}
function handlerNameToEventName(handlerName) {
  return handlerName.substr(2, 1).toLowerCase() + handlerName.substr(3);
}
var CKEditorEventAction = __spreadArray(__spreadArray([], events, true), namespaceEvents, true).reduce(function(acc, evtName) {
  var _a;
  return __assign(__assign({}, acc), (_a = {}, _a[evtName] = prefixEventName(evtName), _a));
}, {});
function camelToKebab(str) {
  return str.split(/(?=[A-Z])/).join("-").toLowerCase();
}
function uniqueName() {
  return Math.random().toString(36).replace(/[^a-z]+/g, "").substr(0, 5);
}
function getStyle(type, status, style) {
  var hidden = { display: "none", visibility: "hidden" };
  if (type === "classic") {
    return hidden;
  }
  return status === "ready" ? style !== null && style !== void 0 ? style : void 0 : hidden;
}
function registerEditorEventHandler(_a) {
  var debug = _a.debug, editor = _a.editor, evtName = _a.evtName, handler = _a.handler, listenerData = _a.listenerData, priority = _a.priority;
  var handlerId = debug && uniqueName();
  var _handler = handler;
  if (debug) {
    _handler = function(args) {
      console.log({
        operation: "invoke",
        editor: editor.name,
        evtName,
        handlerId,
        data: args.data,
        listenerData: args.listenerData
      });
      handler(args);
    };
  }
  if (debug) {
    console.log({
      operation: "register",
      editor: editor.name,
      evtName,
      handlerId
    });
  }
  editor.on(evtName, _handler, null, listenerData, priority);
  return function() {
    if (debug) {
      console.log({
        operation: "unregister",
        editor: editor.name,
        evtName,
        handlerId
      });
    }
    editor.removeListener(evtName, _handler);
  };
}
var useEffect$1 = React.useEffect;
var useReducer2 = React.useReducer;
var useRef$1 = React.useRef;
var defEditorUrl = "https://cdn.ckeditor.com/4.22.1/standard-all/ckeditor.js";
var defConfig = {};
function useCKEditor(_a) {
  var config = _a.config, debug = _a.debug, dispatchEvent = _a.dispatchEvent, _b = _a.subscribeTo, subscribeTo = _b === void 0 ? defaultEvents : _b, editorUrl = _a.editorUrl, element = _a.element, initContent = _a.initContent, _c = _a.type, type = _c === void 0 ? "classic" : _c;
  var editorUrlRef = useRef$1(editorUrl || defEditorUrl);
  var subscribeToRef = useRef$1(subscribeTo !== null && subscribeTo !== void 0 ? subscribeTo : defaultEvents);
  var debugRef = useRef$1(debug);
  var dispatchEventRef = useRef$1(dispatchEvent);
  var initContentRef = useRef$1(initContent);
  var configRef = useRef$1(config || defConfig);
  var typeRef = useRef$1(type);
  var _d = useReducer2(reducer, {
    editor: void 0,
    hookStatus: "init"
  }), _e = _d[0], editor = _e.editor, hookStatus = _e.hookStatus, dispatch = _d[1];
  useEffect$1(function() {
    if (element && !editor) {
      dispatch({ type: "loading" });
      var onNamespaceLoaded = function(CKEDITOR2) {
        var _a2;
        if (subscribeToRef.current.indexOf("namespaceLoaded") !== -1) {
          (_a2 = dispatchEventRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(dispatchEventRef, {
            type: CKEditorEventAction.namespaceLoaded,
            payload: CKEDITOR2
          });
        }
      };
      var initEditor = function(CKEDITOR2) {
        var _a2;
        var isInline = typeRef.current === "inline";
        var isReadOnly = configRef.current.readOnly;
        if (subscribeToRef.current.indexOf("beforeLoad") !== -1) {
          (_a2 = dispatchEventRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(dispatchEventRef, {
            type: CKEditorEventAction.beforeLoad,
            payload: CKEDITOR2
          });
        }
        var editor2 = CKEDITOR2[isInline ? "inline" : "replace"](element, configRef.current);
        var subscribedEditorEvents = subscribeToRef.current.filter(function(evtName) {
          return namespaceEvents.indexOf(evtName) === -1;
        });
        subscribedEditorEvents.forEach(function(evtName) {
          registerEditorEventHandler({
            debug: debugRef.current,
            editor: editor2,
            evtName,
            handler: function(payload) {
              var _a3;
              (_a3 = dispatchEventRef.current) === null || _a3 === void 0 ? void 0 : _a3.call(dispatchEventRef, {
                type: "".concat(EVENT_PREFIX).concat(evtName),
                payload
              });
            }
          });
        });
        registerEditorEventHandler({
          debug: debugRef.current,
          editor: editor2,
          evtName: "loaded",
          handler: function() {
            dispatch({ type: "loaded" });
          },
          priority: -1
        });
        registerEditorEventHandler({
          debug: debugRef.current,
          editor: editor2,
          evtName: "instanceReady",
          handler: function(_a3) {
            var editor3 = _a3.editor;
            dispatch({ type: "ready" });
            if (isInline && !isReadOnly) {
              editor3.setReadOnly(false);
            }
            if (initContentRef.current) {
              editor3.setData(initContentRef.current, {
                noSnapshot: true,
                callback: function() {
                  editor3.resetUndo();
                }
              });
            }
          },
          priority: -1
        });
        registerEditorEventHandler({
          debug: debugRef.current,
          editor: editor2,
          evtName: "destroy",
          handler: function() {
            dispatch({ type: "destroyed" });
          },
          priority: -1
        });
        dispatch({
          type: "unloaded",
          payload: editor2
        });
      };
      getEditorNamespace(editorUrlRef.current, onNamespaceLoaded).then(initEditor).catch(function(error) {
        if (true) {
          console.error(error);
        }
        dispatch({ type: "error" });
      });
    }
    return function() {
      if (editor) {
        editor.destroy();
      }
    };
  }, [editor, element]);
  return {
    editor,
    status: editor === null || editor === void 0 ? void 0 : editor.status,
    error: hookStatus === "error",
    loading: hookStatus === "loading"
  };
}
function reducer(state, action) {
  switch (action.type) {
    case "init":
      return __assign(__assign({}, state), { hookStatus: "init" });
    case "loading":
      return __assign(__assign({}, state), { hookStatus: "loading" });
    case "unloaded":
      return {
        editor: action.payload,
        hookStatus: "unloaded"
      };
    case "loaded":
      return __assign(__assign({}, state), { hookStatus: "loaded" });
    case "ready":
      return __assign(__assign({}, state), { hookStatus: "ready" });
    case "destroyed":
      return {
        editor: void 0,
        hookStatus: "destroyed"
      };
    case "error":
      return {
        editor: void 0,
        hookStatus: "error"
      };
    default:
      return state;
  }
}
var useEffect2 = React.useEffect;
var useRef2 = React.useRef;
var useState2 = React.useState;
function CKEditor(_a) {
  var _b = _a.config, config = _b === void 0 ? {} : _b, debug = _a.debug, editorUrl = _a.editorUrl, initData = _a.initData, name = _a.name, readOnly = _a.readOnly, style = _a.style, type = _a.type, handlers = __rest(_a, ["config", "debug", "editorUrl", "initData", "name", "readOnly", "style", "type"]);
  var _c = useState2(null), element = _c[0], setElement = _c[1];
  var refs = useRef2(handlers);
  var dispatchEvent = function(_a2) {
    var type2 = _a2.type, payload = _a2.payload;
    var handlerName = eventNameToHandlerName(stripPrefix(type2));
    var handler = refs.current[handlerName];
    if (handler) {
      handler(payload);
    }
  };
  if (config && typeof readOnly === "boolean") {
    config.readOnly = readOnly;
  }
  var _d = useCKEditor({
    config,
    dispatchEvent,
    debug,
    editorUrl,
    element,
    initContent: typeof initData === "string" ? initData : void 0,
    subscribeTo: Object.keys(handlers).filter(function(key) {
      return key.indexOf("on") === 0;
    }).map(handlerNameToEventName),
    type
  }), editor = _d.editor, status = _d.status;
  useEffect2(function() {
    var canSetStyles = type !== "inline" && editor && (status === "loaded" || status === "ready");
    if (style && canSetStyles) {
      editor.container.setStyles(style);
    }
    return function() {
      if (style && canSetStyles) {
        Object.keys(style).map(camelToKebab).forEach(function(styleName) {
          editor.container.removeStyle(styleName);
        });
      }
    };
  }, [editor, status, style, type]);
  useEffect2(function() {
    if (editor && status === "ready" && typeof readOnly === "boolean") {
      editor.setReadOnly(readOnly);
    }
  }, [editor, status, readOnly]);
  return React.createElement("div", { id: name !== null && name !== void 0 ? name : void 0, ref: setElement, style: getStyle(type !== null && type !== void 0 ? type : "classic", status, style) }, typeof initData === "string" ? null : initData);
}
var propTypes = __assign({
  config: PropTypes.object,
  debug: PropTypes.bool,
  editorUrl: PropTypes.string,
  initData: PropTypes.node,
  name: PropTypes.string,
  readOnly: PropTypes.bool,
  style: PropTypes.object,
  type: PropTypes.oneOf(["classic", "inline"])
}, defaultEvents.reduce(function(acc, key) {
  var _a;
  return __assign(__assign({}, acc), (_a = {}, _a[eventNameToHandlerName(key)] = PropTypes.func, _a));
}, {}));
CKEditor.propTypes = propTypes;
export {
  CKEditor,
  CKEditorEventAction,
  prefixEventName,
  registerEditorEventHandler,
  stripPrefix,
  useCKEditor
};
/*! Bundled license information:

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

ckeditor4-integrations-common/dist/index.esm.js:
  (**
   * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.
   * For licensing, see LICENSE.md.
   *)

ckeditor4-react/dist/index.esm.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md.
   *)
*/
//# sourceMappingURL=ckeditor4-react.js.map
